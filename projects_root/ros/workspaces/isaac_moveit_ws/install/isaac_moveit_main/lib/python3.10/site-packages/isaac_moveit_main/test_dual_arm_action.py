#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from moveit_msgs.action import MoveGroup
from moveit_msgs.msg import Constraints, PositionConstraint, MotionPlanRequest, PlanningOptions, RobotState
from shape_msgs.msg import SolidPrimitive
from geometry_msgs.msg import PoseStamped
from sensor_msgs.msg import JointState
import time

class DualArmActionTest(Node):
    def __init__(self):
        super().__init__('dual_arm_action_test')
        
        # Create action client for MoveGroup
        self.move_group_client = ActionClient(self, MoveGroup, '/move_action')
        
        # Wait for action server
        self.get_logger().info("Waiting for MoveGroup action server...")
        if not self.move_group_client.wait_for_server(timeout_sec=10.0):
            self.get_logger().error("MoveGroup action server not available!")
            return
        self.get_logger().info("‚úÖ MoveGroup action server ready!")

    def create_dual_arm_goal(self):
        """Create a planning request with pose targets for both end effectors"""
        
        goal = MoveGroup.Goal()
        
        # Configure the planning request
        goal.request.group_name = "all_arms"
        goal.request.num_planning_attempts = 5
        goal.request.allowed_planning_time = 5.0
        goal.request.max_velocity_scaling_factor = 0.1
        goal.request.max_acceleration_scaling_factor = 0.1
        goal.request.planner_id = ""  # Use default planner
        
        # Configure planning options
        goal.planning_options.plan_only = True  # Just plan, don't execute yet
        goal.planning_options.look_around = False
        goal.planning_options.look_around_attempts = 0
        goal.planning_options.max_safe_execution_cost = 1.0
        goal.planning_options.replan = False
        goal.planning_options.replan_attempts = 0
        
        # Create constraints for both end effectors
        constraints = Constraints()
        
        # ===== LEFT ARM POSITION CONSTRAINT =====
        left_constraint = PositionConstraint()
        left_constraint.header.frame_id = "base_link"
        left_constraint.link_name = "left_panda_link8"
        left_constraint.weight = 1.0
        
        # Create constraint region (sphere around target)
        primitive_left = SolidPrimitive()
        primitive_left.type = SolidPrimitive.SPHERE
        primitive_left.dimensions = [0.01]  # 1cm tolerance
        left_constraint.constraint_region.primitives.append(primitive_left)
        
        # Set target pose for left arm
        pose_left = PoseStamped()
        pose_left.header.frame_id = "base_link"
        pose_left.pose.position.x = 0.4
        pose_left.pose.position.y = 0.2  # Left side
        pose_left.pose.position.z = 0.4
        pose_left.pose.orientation.w = 1.0
        left_constraint.constraint_region.primitive_poses.append(pose_left.pose)
        
        # ===== RIGHT ARM POSITION CONSTRAINT =====
        right_constraint = PositionConstraint()
        right_constraint.header.frame_id = "base_link"
        right_constraint.link_name = "right_panda_link8"
        right_constraint.weight = 1.0
        
        # Create constraint region (sphere around target)
        primitive_right = SolidPrimitive()
        primitive_right.type = SolidPrimitive.SPHERE
        primitive_right.dimensions = [0.01]  # 1cm tolerance
        right_constraint.constraint_region.primitives.append(primitive_right)
        
        # Set target pose for right arm
        pose_right = PoseStamped()
        pose_right.header.frame_id = "base_link"
        pose_right.pose.position.x = 0.4
        pose_right.pose.position.y = -0.2  # Right side
        pose_right.pose.position.z = 0.4
        pose_right.pose.orientation.w = 1.0
        right_constraint.constraint_region.primitive_poses.append(pose_right.pose)
        
        # Add both constraints to the planning request
        constraints.position_constraints.append(left_constraint)
        constraints.position_constraints.append(right_constraint)
        goal.request.goal_constraints.append(constraints)
        
        return goal

    async def test_dual_arm_planning(self):
        """Test dual-arm planning using MoveGroup action"""
        
        self.get_logger().info("=== DUAL-ARM PLANNING TEST (Action Interface) ===")
        
        # Create the goal
        goal = self.create_dual_arm_goal()
        
        # Log what we're planning for
        self.get_logger().info(f"Planning group: {goal.request.group_name}")
        self.get_logger().info(f"Number of end effector constraints: {len(goal.request.goal_constraints[0].position_constraints)}")
        
        for i, constraint in enumerate(goal.request.goal_constraints[0].position_constraints):
            self.get_logger().info(f"End effector {i+1}: {constraint.link_name}")
            pos = constraint.constraint_region.primitive_poses[0].position
            self.get_logger().info(f"  Target: x={pos.x:.2f}, y={pos.y:.2f}, z={pos.z:.2f}")
        
        # Send the planning request
        self.get_logger().info("Sending dual-arm planning request...")
        
        try:
            # Send goal asynchronously
            goal_handle_future = self.move_group_client.send_goal_async(goal)
            goal_handle = await goal_handle_future
            
            if not goal_handle.accepted:
                self.get_logger().error("‚ùå Planning goal was rejected!")
                return False
            
            self.get_logger().info("‚úÖ Planning goal accepted! Waiting for result...")
            
            # Wait for the result
            result_future = goal_handle.get_result_async()
            result = await result_future
            
            # Check the planning result
            error_code = result.result.error_code.val
            
            if error_code == 1:  # SUCCESS
                self.get_logger().info("üéâ DUAL-ARM PLANNING SUCCEEDED!")
                
                # Show trajectory info
                trajectory = result.result.planned_trajectory
                if trajectory.joint_trajectory.points:
                    num_points = len(trajectory.joint_trajectory.points)
                    self.get_logger().info(f"‚úÖ Planned trajectory has {num_points} waypoints")
                    
                    # Show which joints are being planned
                    joints = trajectory.joint_trajectory.joint_names
                    self.get_logger().info(f"‚úÖ Planning for {len(joints)} joints:")
                    left_joints = [j for j in joints if 'left' in j]
                    right_joints = [j for j in joints if 'right' in j]
                    self.get_logger().info(f"   Left arm joints: {len(left_joints)}")
                    self.get_logger().info(f"   Right arm joints: {len(right_joints)}")
                    
                    # Show planning time
                    planning_time = result.result.planning_time
                    self.get_logger().info(f"‚úÖ Planning time: {planning_time:.2f} seconds")
                    
                    # Show trajectory duration
                    if num_points > 0:
                        duration = trajectory.joint_trajectory.points[-1].time_from_start
                        self.get_logger().info(f"‚úÖ Trajectory duration: {duration.sec}.{duration.nanosec//1000000:03d} seconds")
                    
                    return True
                else:
                    self.get_logger().warn("Planning succeeded but no trajectory points generated")
                    return False
                    
            else:
                error_names = {
                    -1: "FAILURE",
                    -2: "PLANNING_FAILED", 
                    -3: "INVALID_MOTION_PLAN",
                    -4: "MOTION_PLAN_INVALIDATED_BY_ENVIRONMENT_CHANGE",
                    -5: "CONTROL_FAILED",
                    -6: "UNABLE_TO_AQUIRE_SENSOR_DATA",
                    -7: "TIMED_OUT",
                    -10: "INVALID_GROUP_NAME",
                    -12: "INVALID_GOAL_CONSTRAINTS",
                    -13: "INVALID_STATE_IN_STATE_SPACE",
                    -14: "INVALID_LINK_NAME",
                    -15: "INVALID_OBJECT_NAME",
                    -31: "FRAME_TRANSFORM_FAILURE",
                    -32: "COLLISION_CHECKING_UNAVAILABLE",
                    -33: "ROBOT_STATE_STALE",
                    -34: "SENSOR_INFO_STALE"
                }
                error_name = error_names.get(error_code, f"UNKNOWN_ERROR_{error_code}")
                self.get_logger().error(f"‚ùå PLANNING FAILED! Error: {error_name} (code: {error_code})")
                return False
                
        except Exception as e:
            self.get_logger().error(f"‚ùå Exception during planning: {e}")
            return False

async def main():
    rclpy.init()
    
    test_node = DualArmActionTest()
    
    try:
        success = await test_node.test_dual_arm_planning()
        
        if success:
            test_node.get_logger().info("\nüéâ DUAL-ARM CENTRALIZED PLANNING VERIFIED! üéâ")
            test_node.get_logger().info("‚úÖ Your setup can plan for both end effectors simultaneously")
            test_node.get_logger().info("‚úÖ Using single 'all_arms' planning group")
            test_node.get_logger().info("‚úÖ Separate pose targets for each arm")
            test_node.get_logger().info("‚úÖ Coordinated motion planning")
            test_node.get_logger().info("‚úÖ Ready for your centralized dual-arm applications! üöÄ")
        else:
            test_node.get_logger().info("\n‚ùå Planning test failed")
            test_node.get_logger().info("Check robot workspace limits and collision settings")
            
    except KeyboardInterrupt:
        test_node.get_logger().info("Test interrupted by user")
    finally:
        test_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    # import asyncio
    asyncio.run(main()) 