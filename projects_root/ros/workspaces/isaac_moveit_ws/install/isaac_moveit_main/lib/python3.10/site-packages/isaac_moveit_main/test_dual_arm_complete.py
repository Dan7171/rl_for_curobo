#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from moveit_msgs.action import MoveGroup
from moveit_msgs.msg import Constraints, PositionConstraint
from geometry_msgs.msg import Pose
from shape_msgs.msg import SolidPrimitive
from rclpy.action import ActionClient
import time

class DualArmCompleteTest(Node):
    def __init__(self):
        super().__init__('dual_arm_complete_test')
        
        # Create action client for MoveGroup
        self.move_group_client = ActionClient(self, MoveGroup, '/move_action')
        
        # Wait for action server
        self.get_logger().info("Waiting for MoveGroup action server...")
        if not self.move_group_client.wait_for_server(timeout_sec=10.0):
            self.get_logger().error("MoveGroup action server not available!")
            return
        self.get_logger().info("MoveGroup action server ready!")

    def create_dual_arm_goal(self, plan_only=True):
        """Create a planning request with goals for both end effectors"""
        
        goal = MoveGroup.Goal()
        
        # Set the planning group to all_arms for centralized planning
        goal.request.group_name = "all_arms"
        goal.request.num_planning_attempts = 10
        goal.request.allowed_planning_time = 10.0
        goal.request.max_velocity_scaling_factor = 0.1
        goal.request.max_acceleration_scaling_factor = 0.1
        goal.request.planner_id = ""  # Use default planner
        goal.request.pipeline_id = "ompl"  # Use OMPL pipeline
        
        # Set if we want to plan only or plan and execute
        goal.planning_options.plan_only = plan_only
        goal.planning_options.look_around = False
        goal.planning_options.look_around_attempts = 0
        goal.planning_options.max_safe_execution_cost = 1.0
        goal.planning_options.replan = False
        goal.planning_options.replan_attempts = 0
        goal.planning_options.replan_delay = 0.1
        
        # Define goal constraints for BOTH end effectors
        constraints = Constraints()
        
        # ===== LEFT ARM END EFFECTOR GOAL =====
        left_constraint = PositionConstraint()
        left_constraint.header.frame_id = "base_link"
        left_constraint.link_name = "left_panda_link8"
        
        # Create constraint region
        primitive_left = SolidPrimitive()
        primitive_left.type = SolidPrimitive.SPHERE
        primitive_left.dimensions = [0.02]  # 2cm tolerance
        left_constraint.constraint_region.primitives.append(primitive_left)
        
        # Set target pose for left arm (move to a reachable position)
        pose_left = Pose()
        pose_left.position.x = 0.4
        pose_left.position.y = 0.2  # Left side
        pose_left.position.z = 0.3
        pose_left.orientation.w = 1.0
        left_constraint.constraint_region.primitive_poses.append(pose_left)
        left_constraint.weight = 1.0
        
        # ===== RIGHT ARM END EFFECTOR GOAL =====
        right_constraint = PositionConstraint()
        right_constraint.header.frame_id = "base_link"
        right_constraint.link_name = "right_panda_link8"
        
        # Create constraint region
        primitive_right = SolidPrimitive()
        primitive_right.type = SolidPrimitive.SPHERE
        primitive_right.dimensions = [0.02]  # 2cm tolerance
        right_constraint.constraint_region.primitives.append(primitive_right)
        
        # Set target pose for right arm (move to a reachable position)
        pose_right = Pose()
        pose_right.position.x = 0.4
        pose_right.position.y = -0.2  # Right side
        pose_right.position.z = 0.3
        pose_right.orientation.w = 1.0
        right_constraint.constraint_region.primitive_poses.append(pose_right)
        right_constraint.weight = 1.0
        
        # Add both constraints
        constraints.position_constraints.append(left_constraint)
        constraints.position_constraints.append(right_constraint)
        goal.request.goal_constraints.append(constraints)
        
        return goal

    async def test_dual_arm_planning_complete(self):
        """Test complete dual-arm planning with results"""
        
        self.get_logger().info("=== DUAL-ARM CENTRALIZED PLANNING TEST ===")
        
        # First, test planning only
        self.get_logger().info("Step 1: Testing PLANNING for both end effectors...")
        goal = self.create_dual_arm_goal(plan_only=True)
        
        self.get_logger().info(f"Planning group: {goal.request.group_name}")
        self.get_logger().info(f"Number of end effector constraints: {len(goal.request.goal_constraints[0].position_constraints)}")
        
        for i, constraint in enumerate(goal.request.goal_constraints[0].position_constraints):
            self.get_logger().info(f"End effector {i+1}: {constraint.link_name}")
            pos = constraint.constraint_region.primitive_poses[0].position
            self.get_logger().info(f"  Target: x={pos.x:.2f}, y={pos.y:.2f}, z={pos.z:.2f}")
        
        # Send planning goal
        self.get_logger().info("Sending planning request...")
        goal_handle = await self.move_group_client.send_goal_async(goal)
        
        if not goal_handle.accepted:
            self.get_logger().error("Goal was rejected!")
            return False
            
        self.get_logger().info("Goal accepted! Waiting for planning result...")
        
        # Wait for result
        result = await goal_handle.get_result_async()
        
        # Check planning result
        if result.result.error_code.val == 1:  # SUCCESS
            self.get_logger().info("‚úÖ PLANNING SUCCEEDED!")
            self.get_logger().info(f"Planned trajectory has {len(result.result.planned_trajectory.joint_trajectory.points)} waypoints")
            self.get_logger().info(f"Planning time: {result.result.planning_time:.2f} seconds")
            
            # Show trajectory info
            if len(result.result.planned_trajectory.joint_trajectory.points) > 0:
                duration = result.result.planned_trajectory.joint_trajectory.points[-1].time_from_start
                self.get_logger().info(f"Trajectory duration: {duration.sec}.{duration.nanosec//1000000:03d} seconds")
                
                # Now test execution
                return await self.test_execution(goal)
        else:
            self.get_logger().error(f"‚ùå PLANNING FAILED! Error code: {result.result.error_code.val}")
            return False

    async def test_execution(self, plan_goal):
        """Test executing the planned trajectory"""
        
        self.get_logger().info("\nStep 2: Testing EXECUTION...")
        user_input = input("Do you want to execute the planned motion? (y/n): ")
        
        if user_input.lower() != 'y':
            self.get_logger().info("Execution skipped by user.")
            return True
            
        # Create execution goal
        exec_goal = self.create_dual_arm_goal(plan_only=False)
        
        self.get_logger().info("Sending plan & execute request...")
        goal_handle = await self.move_group_client.send_goal_async(exec_goal)
        
        if not goal_handle.accepted:
            self.get_logger().error("Execution goal was rejected!")
            return False
            
        self.get_logger().info("Execution goal accepted! Robot should be moving...")
        
        # Wait for execution result
        result = await goal_handle.get_result_async()
        
        if result.result.error_code.val == 1:  # SUCCESS
            self.get_logger().info("‚úÖ EXECUTION SUCCEEDED!")
            self.get_logger().info("Both arms moved to their target positions!")
            return True
        else:
            self.get_logger().error(f"‚ùå EXECUTION FAILED! Error code: {result.result.error_code.val}")
            return False

async def main():
    rclpy.init()
    
    test_node = DualArmCompleteTest()
    
    try:
        success = await test_node.test_dual_arm_planning_complete()
        
        if success:
            test_node.get_logger().info("\nüéâ DUAL-ARM CENTRALIZED PLANNING VERIFIED! üéâ")
            test_node.get_logger().info("‚úÖ You can plan for both end effectors simultaneously")
            test_node.get_logger().info("‚úÖ Using single 'all_arms' planning group")
            test_node.get_logger().info("‚úÖ Centralized coordination between arms")
        else:
            test_node.get_logger().info("\n‚ùå Test failed - check MoveIt configuration")
            
    except KeyboardInterrupt:
        test_node.get_logger().info("Test interrupted by user")
    finally:
        test_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    import asyncio
    asyncio.run(main()) 