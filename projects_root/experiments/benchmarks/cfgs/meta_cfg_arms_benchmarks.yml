benchmark_mode: 
  is_on: True
  robot_fam: ur5e # ur10e
  n_arms: 4 # 4
  alg: 'CC' # CC, O, SD, SC, D, O-

default: # default values to fallback to if not specified in the agent cfg. Note: you can specify agent-specific values here for each of  the default values in this file (see below).
  is_mobile: False
  mobile_base_link_subpath: ''
  cu_world_wrapper: # curoboworld collision wrapper
    verbosity: 4 # 0 to 4 (0 is no output, 4 is max output) 
    never_add: [] # paths of objects that should never be added to the collision world (for example, robot itself or the robot target)
    never_update: [] # paths of objects that are added at the beginning of the simulation and should never be updated in the collision world (normally should set here the static objects, like the ground)

  
  cumotion: # cumotion related default values (if not specified by the agent)
    motion_gen_cfg:
      use_cuda_graph: True 
      self_collision_check: True
      collision_checker_type: MESH
      collision_cache: {"obb": 15, "mesh": 15}
      interpolation_dt: 0.03
      collision_activation_distance: 0.025
      fixed_iters_trajopt: True
      maximum_trajectory_dt: 0.5
      ik_opt_iters: 500
    
    motion_gen_plan_cfg:
      enable_graph: False
      enable_graph_attempt: 4
      max_attempts: 10
      time_dilation_factor: 0.5
    
    warmup_cfg:
      enable_graph: True
      warmup_js_trajopt: False
    
  
  mpc: # mpc related default values (if not specified in the agent)
    mpc_solver_cfg:
      override_particle_file: projects_root/experiments/benchmarks/cfgs/particle_file_arms.yml 
      use_cuda_graph: False 
      step_dt: 0.02
      use_cuda_graph_metrics: False
      self_collision_check: True
      collision_checker_type: MESH
      collision_cache: {"obb": 15, "mesh": 15}
      use_mppi: True
      use_lbfgs: False
      plot_costs: False # for debugging

  
  sim_robot_cfg: # default values for SimRobot class which is used to control the robot in simulation (if not specified by the agent)
    visualize_col_spheres: # visualize collision spheres of the robot (for debugging)
      is_on: False # currently has an issue with rotation-showing wrong orientation smetimes
      ts_delta: 2 # int
      color: viz_color

    visualize_obj_bound_spheres: # show sphres bounding curobo obstacles (for debugging)
      is_on: False
      ts_delta: 2 # int
      

    visualize_plan: # visualize the planned trajectory of the robot (for debugging)
      is_on: False
      color: viz_color
      ts_delta: 1 # int
    
    visualize_mpc_ee_rollouts: # visualize the end-effector rollouts of the mpc (for debugging)
      is_on: False
      color: 'green'
      ts_delta: 1 # int

    visualize_col_pred:
      own: True
      own_color: 'blue'
      own_mean_only: True
      obs: False
      obs_color: 'red'
      
      ts_delta: 1 # int


  plan_pub_sub: # default values for publishing and subscribing to plans (if not specified by the agent)
    pub:
      is_on: False # meaning agent is publishing plans (so they can be used by other agents). If false, plan will be just the current state of the robot.
      dt: 1 # agent will publish plans every pub_dt steps or seconds
      is_dt_in_sec: False # if True, dt is in seconds, if False, pub_dt is in steps
      pr: 1.0 # probability of publishing the plans (0.0 to 1.0) *when* dt is reached.
    sub:
      is_on: True # meaning agent is subscribing to plans from other robots
      to: 'all' # meaning agent will subscribe to plans from all robots (except itself). 'to' can be a list of robot indices or 'all'. When agent is subscribed to plans, it will use the plans to plan its own steps (to make collision free steps).
      
  

# default (and only) values for environments (sim/real) 
env:
  simulation: # todo
    is_on: True
    enable_gpu_dynamics: True
    init_app_settings:
      headless: null # set 'true' to run in headless mode
      width: "1920"
      height: "1080"
      # physics_dt: 0.03 # 0.016666666666666666 # 0.016666666666666666
      # rendering_dt: 0.03 # 0.016666666666666666 # 0.016666666666666666
      backend: "torch"
  
  real: # todo
    is_on: False
  
async: False
async_type: "step" # "step" or "loop"

pose_utils:
  seed: 0 # seed to sample the obstacle poses

sim_task:
  # task_type: 'manual' # reach/follow/manual (for debugging)
  task_type: manual # bin # manual # reach # 'CBSMP1' # reach/follow/manual/CBSMP_1 (for debugging)
  stats_cfg:
    collect: False # if True, the stats will be collected and saved to a file
    collect_list: [contact, goal_error, spheres]
    collect_dt: [1,5,3] # save stats every save_stats_dt steps
    verbose: [False,False,False]
    save_path: "projects_root/experiments/out" # path to save the stats
    add_timestep_to_path: True # if True, the timestep will be added to the path of the stats file
    save: False # if True, the stats will be saved to a file

  cfg:
    wall_dims_hwd: [0.4,0.5,0.05] # height, width, depth of the bin walls
    bin_pose: [0,0,0,1,0,0,0] # position and orientation of the bin (xyz, wxyz)
    # pos_err_tol = 0.03 # position error tolerance
    # rot_err_tol = 
  # cfg:
    
sim_env:
  cfg:
    n_obs: 2
    obj_shape: 'sphere' # type of the obstacle ('cube' or 'sphere')
    max_dim: 0.1 # max dimension of the obstacle (in meters): side length for cube, diameter for sphere
    min_dim: 0.1 # min dimension of the obstacle (in meters): side length for cube, diameter for sphere
    volume_center_pos: [0, 0,0.5] # center position of the obstacle volume (xyz in world frame)
    volume_shape: 'sphere' # shape of the obstacle volume ('sphere' or 'box')
    volume_dim: 1 # dimension of the obstacle volume (radius for sphere, side length for box)
    obj_lin_vel: [0,0,0] # [0.2,0.2,0.2] # velocity of the obstacle (xyz in world frame)
    obj_rigid_body_enabled: False # if True, the obstacle will be a rigid body (for physics)

sim_stats: 
  collect_dt: 25
  verbosity: True

