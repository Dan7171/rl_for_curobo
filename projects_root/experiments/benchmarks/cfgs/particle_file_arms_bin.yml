model:
  horizon: 30
  state_filter_cfg:
    filter_coeff:
      position: 0.1
      velocity: 0.1
      acceleration: 0.0
    enable: True
  dt_traj_params:
    base_dt: 0.01
    base_ratio: 0.5
    max_dt: 0.04
  vel_scale: 1.0
  control_space: 'ACCELERATION'
  teleport_mode: False
  state_finite_difference_mode: "CENTRAL"


cost:
  pose_cfg:
    vec_weight: [1.0,1.0, 1.0, 1.0, 1.0, 1.0]
    run_vec_weight: [1.0,1.0, 1.0, 1.0, 1.0, 1.0]
    weight: [5.0,300.0,2.0,20] #[150.0, 2000.0, 30, 40]
    vec_convergence: [0.0, 0.00] # orientation, position
    terminal: True
    run_weight: 1.0
    use_metric: True

  cspace_cfg:
    weight: 1000.0
    terminal: True
    run_weight: 1.0

  bound_cfg:
    weight: [5000.0, 5000.0,5000.0,000.0]
    activation_distance: [0.1,0.1,0.1,0.1] # for position, velocity, acceleration and jerk
    smooth_weight: [0.0, 50.0, 0.0,0.0] # [vel, acc, jerk, alpha_vel, eta_position, eta_vel, eta_acc]
    run_weight_velocity: 0.0
    run_weight_acceleration: 1.0
    run_weight_jerk: 1.0
    null_space_weight: [10.0]

  primitive_collision_cfg:
    weight: 100000.0
    use_sweep: True
    sweep_steps: 4
    classify: False
    use_sweep_kernel: True
    use_speed_metric: False
    speed_dt: 0.1 # used only for speed metric
    activation_distance: 0.025

  self_collision_cfg:
    weight: 50000.0
    classify: False


  stop_cfg:
    weight: 100.0 #50.0
    max_nlimit: 0.25 #0.2

  custom:  
    published_info:
      spheres_to_exclude_in_sparse_mode: []  # User will fill this later

    arm_base:
      dynamic_obs_cost:
        module_path: "curobo.rollout.cost.custom.arm_base.dynamic_obs_cost"
        class_name: "DynamicObsCost"
        config_class_name: "DynamicObsCostConfig"
        a_select_mode: normal # 'col_free' # col_free  # col free will make sure action is selected from rollout with min(w) over all col free rollouts (when mppi[sample_mode] = BEST )
        weight: 1000.0  # 100  
        terminal: False
        safety_margin: 0.05
        prior_rule: pose # rule of prioratization: none/pose/random
        prior_p_err_impact_rad: 0.2 # if link error is >= this, then the dynamic obs cost is not affected by the pose cost
        prior_rot_err_impact_angle: 180 # if error (in mean rotation error per axis (total rotation error / 3)) is >= this, then the dynamic obs cost is not affected by the pose cost
        prior_keep_lower_bound: 0.0 # between 0 and 1.A lower bound on how much we keep from the origianl dynamic obs cost. 0 means no lower bound. 1 means keep all.
        prior_pos_to_rot_ratio: 1.0 # TODO- Fix rotation error check(until then use 1.0). If rule is pose, then (if both pos and rot are in affection radius/limit) we will scale the dynamic obs cost by this ratio. 1 means using position and ignoring rotation completetly, 0 means using rotation and ignoring position completetly.
        prior_weight_mode: linear # linear or exponential
        sparse_steps:
          use: False
          ratio: 0.2
        sparse_spheres:
          use: True



mppi:
  init_cov          : 0.05 #.5 #.5
  gamma             : 0.98
  n_iters           : 5
  cold_start_n_iters: 5
  step_size_mean    : 0.9
  step_size_cov     : 0.01
  beta              : 0.1 # 1.0 # 0.1
  alpha             : 1
  num_particles     : 200 #10000
  update_cov        : True
  cov_type          : "DIAG_A" #
  kappa             : 0.0001
  null_act_frac     : 0.05
  sample_mode       : 'BEST'
  base_action       : 'REPEAT'
  squash_fn         : 'CLAMP'
  n_problems        : 1
  use_cuda_graph    : True
  seed              : 0
  store_debug       : False
  random_mean       : True
  sample_per_problem: False
  sync_cuda_time    : True
  use_coo_sparse    : True
  sample_params:
    fixed_samples: True
    sample_ratio: {'halton':0.3, 'halton-knot':0.7, 'random':0.0, 'random-knot':0.0}
    seed: 0
    filter_coeffs: [0.3, 0.3, 0.4]
    n_knots: 5
  debug_info:
    visual_traj       : 'ee_pos_seq'
